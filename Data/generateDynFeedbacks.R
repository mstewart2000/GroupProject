########################################################################################################################
#### MASTER CODE generating the feedback values for different ages (i.e. demographically dynamic feedback) ############
#### This function takes in the feedback matrix generated by "defineFeed.R" and modifies it LINEARLY ###################
########################################################################################################################
#### There are now currently 19 options of feedback dynamics (i.e. the direction parameter) to choose from: 
#### TYPE I -- All S_{ij} have the same moving characteristics
#### (1)  'mag';             Start-> INPUT feedback;  Action -> intensify with IDENTICAL SLOPE;  End -> MAXIMUM/MINIMUM CONSTRAINT
#### (2)  'decay';           Start-> INPUT feedback;  Action -> weaken with IDENTICAL SLOPE;  End -> ONE (i.e. NO FEEDBACK)
#### (3)  'flip';            Start-> INPUT feedback;  Action -> flip in sign with IDENTICAL SLOPE;  End -> MAXIMUM/MINIMUM CONSTRAINT 
#### (4)  'diverge';         Start-> ONE (i.e. NO FEEDBACK);  Action -> intensify with IDENTICAL SLOPE;  End -> INPUT feedback
#### (5)  'brownian';        Start-> INPUT feedback;  Action -> Random walk with IDENTICAL VARIANCE;  End -> Random walk with MAXIMUM/MINIMUM CONSTRAINT
####
####
#### TYPE II -- S_{ij} can have different moving characteristics
#### (6)  'bidirect.extreme';         Start-> INPUT feedback;  Action -> intensify || weaken with IDENTICAL SLOPE;  End -> MAXIMUM/MINIMUM CONSTRAINT || ONE
#### (7)  'bidirect.polar';           Start-> INPUT feedback;  Action -> intensify || flip in sign with IDENTICAL SLOPE;  End -> MAXIMUM/MINIMUM CONSTRAINT
####
####
#### TYPE III -- Alternatives of previous scenarios with species-specific slopes
#### (8)  'slope.mag';       Start-> INPUT feedback;  Action -> intensify with SPECIES-SPECIFIC SLOPE;  End -> MAXIMUM/MINIMUM CONSTRAINT
#### (9)  'slope.decay';     Start-> INPUT feedback;  Action -> weaken with SPECIES-SPECIFIC SLOPE;  End -> ONE (i.e. NO FEEDBACK)
#### (10) 'slope.flip';      Start-> INPUT feedback;  Action -> flip in sign with SPECIES-SPECIFIC SLOPE;  End -> MAXIMUM/MINIMUM CONSTRAINT 
#### (11) 'slope.diverge';   Start-> ONE (i.e. NO FEEDBACK);  Action -> intensify with SPECIES-SPECIFIC SLOPE;  End -> INPUT feedback
#### (12) 'slope.bidirect.extreme';   Start-> INPUT feedback;  Action -> intensify || weaken with SPECIES-SPECIFIC SLOPE;  End -> MAXIMUM/MINIMUM CONSTRAINT || ONE
#### (13) 'slope.bidirect.polar';     Start-> INPUT feedback;  Action -> intensify || flip in sign with SPECIES-SPECIFIC SLOPE;  End -> MAXIMUM/MINIMUM CONSTRAINT
####
####
#### TYPE IV -- Alternatives of previous scenarios without a maximum/minimum constraint
#### (14) 'forever.mag';     Start-> INPUT feedback;  Action -> intensify with IDENTICAL SLOPE;  End -> INFINITY
#### (15) 'forever.flip';    Start-> INPUT feedback;  Action -> flip in sign with IDENTICAL SLOPE;  End -> INFINITY
#### (16) 'forever.bidirect.polar';   Start-> INPUT feedback;  Action -> intensify || flip in sign with IDENTICAL SLOPE;  End -> INFINITY
####
####
#### TYPE V -- Alternatives of previous scenarios with species-specific slopes and without a maximum/minimum constraint
#### (17) 'forever.slope.mag';     Start-> INPUT feedback;  Action -> intensify with SPECIES-SPECIFIC SLOPE;  End -> INFINITY
#### (18) 'forever.slope.flip';    Start-> INPUT feedback;  Action -> flip in sign with SPECIES-SPECIFIC SLOPE;  End -> INFINITY
#### (19) 'forever.slope.bidirect.polar';   Start-> INPUT feedback;  Action -> intensify || flip in sign with SPECIES-SPECIFIC SLOPE;  End -> INFINITY
########################################################################################################################


#### This function takes in: 
####      (1) feed.array: the original feedback matrix generated by "defineFeed.R" (i.e. the $feed part of the output)
####      (2) depth: the length of the 3rd array dimension representing time/age, this can be as long as possible, or adjust according to observed age distribution
####      (3) increment: the linear increment of feedback strength after each time/age increment
####      (4) direction: the given option of demographically dynamic feedback 
####      (5) pos.feed.max: the maximum of positive feedback that one can reach after long temporal development (default is 1.5)
####      (6) neg.feed.max: the maximum of negative feedback that one can reach after long temporal development (default is 0.5)
####      (7) brownian: coefficient determining Brownian motion details (default is 0.05)
####      (8) slope.array: a matrix of slopes which the feedback strength is changing. If not provided, the function will randomly generate one
####      (9) bidirect.array: a matrix of c(-1=attenuate, 1=intensify) indicating the direction of change. If not provided, the function will randomly generate one
####      (10) slope.min: the minimum slope value when randomly generating a matrix of slopes 
####      (11) slope.max: the maximum slope value when randomly generating a matrix of slopes
generateDemogFeedbacks <- function(feed.array, 
                                   depth, 
                                   increment, 
                                   direction = 'mag', 
                                   pos.feed.max = 1.5, 
                                   neg.feed.max = 0.5, 
                                   brownian = 0.05,
                                   bidirect.array = NA, 
                                   slope.array = NA, 
                                   slope.min = 0.01, 
                                   slope.max = 0.1){
  
  # Reiterate input variables (i.e. place-holders)
  feed <- feed.array
  scope <- depth
  inc <- increment
  
  
  ########################################################################################################################
  #### (1)  'mag'
  #### Start-> INPUT feedback;  Action -> intensify with IDENTICAL SLOPE;  End -> MAXIMUM/MINIMUM CONSTRAINT
  if (direction == 'mag'){
    
    # Create a 3-deminsion array  (i.e. a feedback matrix with a 3rd dimension: temporal change through time/age) 
    magnify.dyn <- array(dim=c(nrow(feed), ncol(feed), scope))
    
    # Set the feedback for the very first time step as the original input
    magnify.dyn[, , 1] <- feed
    
    # Set up movement for each time step
    movement <- ifelse(feed[, ] > 1, 1, -1) * inc 
    
    # For each next time/age step (i.e. k-loop)
    # (a) Increase/decrease the strength of positive/negative feedback by given increment from the value of the previous time step
    # (b) If there was originally no feedback, the value remains 1
    # (c) If the positive/negative feedback strength exceeds pos.feed.max/neg.feed.max, set it to pos.feed.max/neg.feed.max
    for(k in 2:scope){
      magnify.dyn[, , k] <- magnify.dyn[, , k-1] + movement
      magnify.dyn[, , k] <- ifelse(magnify.dyn[, , k-1] == 1, 1, magnify.dyn[, , k])
      magnify.dyn[, , k] <- ifelse(((magnify.dyn[, , k] > pos.feed.max) | (magnify.dyn[, , k] < neg.feed.max)), 
                                   ((magnify.dyn[, , k] > 1)*pos.feed.max + (magnify.dyn[, , k] < 1)*neg.feed.max), magnify.dyn[, , k])
    }
    output <- list(dyn.feedback = magnify.dyn)
  }

    # ##############################################################
    # #### Code original inside the "if(direction == 'mag')" statement from Peter Zee
    # for ( i in 1:nrow(feed)){
    #   for (j in 1:ncol(feed)){
    #     
    #     a <- feed[i, j]
    #     magnify.dyn[i, j, 1] <- a
    #     
    #     for (k in 2:scope){
    #       if (!is.na(a)){
    #         if (a > 1){
    #           magnify.dyn[i,j,k] <- magnify.dyn[i,j,k-1] + inc
    #           if (magnify.dyn[i,j,k] > 1.5){
    #             magnify.dyn[i,j,k] <- 1.5
    #           }
    #         } 
    #         
    #         if (a < 1){
    #           magnify.dyn[i,j,k] <- magnify.dyn[i,j,k-1] - inc
    #           if (magnify.dyn[i,j,k] < 0.5){
    #             magnify.dyn[i,j,k] <- 0.5
    #           }
    #         }
    #         
    #         if (a == 1){
    #           magnify.dyn[i,j,k] <- 1
    #         }
    #       } else {
    #         magnify.dyn[i,j,k] <- NA
    #       }
    #     }
    #   }
    # }
    # output <- list(dyn.feedback = magnify.dyn)
    # ##############################################################
   
  
  ########################################################################################################################
  #### (2)  'decay'          
  #### Start-> INPUT feedback;  Action -> weaken with IDENTICAL SLOPE;  End -> ONE (i.e. NO FEEDBACK)
  if (direction == 'decay'){
    
    # Create a 3-deminsion array  (i.e. a feedback matrix with a 3rd dimension: temporal change through time/age) 
    decay.dyn <- array(dim=c(nrow(feed), ncol(feed), scope))
    
    # Set the feedback for the very first time step as the original input
    decay.dyn[, , 1] <- feed
    
    # Set up movement for each time step
    movement <- ifelse(feed[, ] > 1, -1, 1) * inc 
    
    # For each next time/age step (i.e. k-loop)
    # (a) Decrease/increase the strength of positive/negative feedback by given increment from the value of the previous time step
    # (b) If there was originally no feedback, the value remains 1
    # (c) If the positive/negative feedback strength decreases/increases to below/above 1, set it as 1
    for(k in 2:scope){
      decay.dyn[, , k] <- decay.dyn[, , k-1] + movement
      decay.dyn[, , k] <- ifelse(decay.dyn[, , k-1] == 1, 1, decay.dyn[, , k])
      decay.dyn[, , k] <- ifelse(((decay.dyn[, , k] - 1) * (decay.dyn[, , k-1] - 1)) <= 0, 1, decay.dyn[, , k])
    }
    output <- list(dyn.feedback =  decay.dyn)
  }
    
    # ##############################################################
    # #### Code original inside the "if(direction == 'mag')" statement from Peter Zee
    # for ( i in 1:nrow(feed)){
    #   for (j in 1:ncol(feed)){
    #     
    #     a <- feed[i,j]
    #     decay.dyn[i,j,1] <- a
    #     
    #     for (k in 2:scope){
    #       if (!is.na(a)){
    #         if (a > 1){
    #           decay.dyn[i,j,k] <- decay.dyn[i,j,k-1] - inc
    #           if (decay.dyn[i,j,k] < 1){
    #             decay.dyn[i,j,k] <- 1
    #           }
    #         } 
    #         
    #         if (a < 1){
    #           decay.dyn[i,j,k] <- decay.dyn[i,j,k-1] + inc
    #           if (decay.dyn[i,j,k] > 1){
    #             decay.dyn[i,j,k] <- 1
    #           }
    #         }
    #         
    #         if (a == 1){
    #           decay.dyn[i,j,k] <- 1
    #         }
    #       } else {
    #         decay.dyn[i,j,k] <- NA
    #       }
    #     }
    #   }
    # }
    # 
    # output <- list(dyn.feedback = decay.dyn)
    # ##############################################################
  
  
  ########################################################################################################################
  #### (3)  'flip'
  #### Start-> INPUT feedback;  Action -> flip in sign with IDENTICAL SLOPE;  End -> MAXIMUM/MINIMUM CONSTRAINT 
  if (direction == 'flip'){
    
    # Create a 3-deminsion array  (i.e. a feedback matrix with a 3rd dimension: temporal change through time/age) 
    flip.dyn <- array(dim=c(nrow(feed), ncol(feed), scope))
    
    # Set the feedback for the very first time step as the original input
    flip.dyn[, , 1] <- feed
    
    # Set up movement for each time step
    movement <- ifelse(feed[, ] > 1, -1, 1) * inc 
    
    # For each next time/age step (i.e. k-loop)
    # (a) Decrease/increase the strength of positive/negative feedback by given increment from the value of the previous time step
    # (b) If there was originally no feedback, the value remains 1
    # (c) If the positive/negative feedback strength exceeds pos.feed.max/neg.feed.max, set it to pos.feed.max/neg.feed.max
    for(k in 2:scope){
      flip.dyn[, , k] <- flip.dyn[, , k-1] + movement
      flip.dyn[, , k] <- ifelse(flip.dyn[, , k-1] == 1, 1, flip.dyn[, , k])
      flip.dyn[, , k] <- ifelse(((flip.dyn[, , k] > pos.feed.max) | (flip.dyn[, , k] < neg.feed.max)), 
                                ((flip.dyn[, , k] > 1)*pos.feed.max + (flip.dyn[, , k] < 1)*neg.feed.max), flip.dyn[, , k])
    }
    output <- list(dyn.feedback =  flip.dyn)
  }
  
  
  ########################################################################################################################
  #### (4)  'diverge'
  #### Start-> ONE (i.e. NO FEEDBACK);  Action -> intensify with IDENTICAL SLOPE;  End -> INPUT feedback
  if (direction == 'diverge'){
    
    # Create a 3-deminsion array  (i.e. a feedback matrix with a 3rd dimension: temporal change through time/age) 
    diverge.dyn <- array(dim=c(nrow(feed), ncol(feed), scope))
    
    # Set the feedback for the very first time step as 1
    diverge.dyn[, , 1] <- 1
    
    # Set up movement for each time step
    movement <- ifelse(feed[, ] > 1, 1, -1) * inc
    
    # For each next time/age step (i.e. k-loop)
    # (a) If there was originally no feedback, the value remains 1
    # (b) Increase/decrease the strength by given increment towards the targeted positive/negative feedback set by the input 'feed'
    # (c) If the positive/negative feedback strength exceeds that set by 'feed', stay at the assigned value since that is the maximum/minimum
    for(k in 2:scope){
      diverge.dyn[, , k] <- ifelse(diverge.dyn[, , k-1] != feed[, ], diverge.dyn[, , k-1] + movement, diverge.dyn[, , k-1])
      diverge.dyn[, , k] <- ifelse(((diverge.dyn[, , k] - feed[, ]) * (diverge.dyn[, , k-1] - feed[, ])) <= 0, feed[, ], diverge.dyn[, , k])
    }
    output <- list(dyn.feedback =  diverge.dyn)
  }  
  
  
  ########################################################################################################################
  #### (5)  'brownian'
  #### Start-> INPUT feedback;  Action -> Random walk with IDENTICAL VARIANCE;  End -> Random walk with MAXIMUM/MINIMUM CONSTRAINT
  if (direction == 'brownian'){
    
    # Create a 3-deminsion array  (i.e. a feedback matrix with a 3rd dimension: temporal change through time/age) 
    brownian.dyn <- array(dim=c(nrow(feed), ncol(feed), scope))
    
    # Set the feedback for the very first time step as the original input
    brownian.dyn[, , 1] <- feed
    
    # For each next time/age step (i.e. k-loop)
    # Add a random walk step, sampled from normal distribution with given variance, to the original position
    for (i in 2:scope){
      brownian.dyn[, , i] <- brownian.dyn[, , i-1] + rnorm(length(feed), 0, brownian)
    }
    
    # If the positive/negative feedback strength exceeds pos.feed.max/neg.feed.max, set it to pos.feed.max/neg.feed.max
    brownian.dyn[brownian.dyn < 0.5] <- 0.5
    brownian.dyn[brownian.dyn > 1.5] <- 1.5
    output <- list(dyn.feedback = brownian.dyn)
  }
  
  
  ########################################################################################################################
  #### (6)  'bidirect.extreme'
  #### Start-> INPUT feedback;  Action -> intensify || weaken with IDENTICAL SLOPE;  End -> MAXIMUM/MINIMUM CONSTRAINT || ONE
  if (direction == 'bidirect.extreme'){
    
    # Create a 3-deminsion array  (i.e. a feedback matrix with a 3rd dimension: temporal change through time/age) 
    bidirect.dyn <- array(dim=c(nrow(feed), ncol(feed), scope))
    
    # Set the feedback for the very first time step as the original input
    bidirect.dyn[, , 1] <- feed
    
    # Set up movement for each time step
    # Get matrix for bidirectionality, either randomly generate it or take from input
    if(is.na(sum(bidirect.array))) {bidirect.array <- matrix(sample(c(-1, 1), replace=TRUE, size=nrow(feed) * ncol(feed)), nrow(feed), ncol(feed))}
    if(!is.na(sum(bidirect.array))) {bidirect.array <- bidirect.array}
    movement <- bidirect.array * ifelse(feed[, ] > 1, 1, -1) * inc
    
    # For each next time/age step (i.e. k-loop)
    # (a) Increase/decrease the strength of feedback based on the given bidirect arrary (-1's attenuate; 1's intensify)
    # (b) If there was originally no feedback, the value remains 1
    # (c) If the positive/negative feedback strength exceeds pos.feed.max/neg.feed.max || crosses one, set it to pos.feed.max/neg.feed.max || one
    for(k in 2:scope){
      bidirect.dyn[, , k] <- bidirect.dyn[, , k-1] + movement
      bidirect.dyn[, , k] <- ifelse(bidirect.dyn[, , k-1] == 1, 1, bidirect.dyn[, , k])
      bidirect.dyn[, , k] <- ifelse(((bidirect.dyn[, , k] - 1) * (bidirect.dyn[, , k-1] - 1)) <= 0, 1, bidirect.dyn[, , k])
      bidirect.dyn[, , k] <- ifelse(((bidirect.dyn[, , k] > pos.feed.max) | (bidirect.dyn[, , k] < neg.feed.max)), 
                                    ((bidirect.dyn[, , k] > 1)*pos.feed.max + (bidirect.dyn[, , k] < 1)*neg.feed.max), bidirect.dyn[, , k])
      
    }
    output <- list(dyn.feedback =  bidirect.dyn, input.array = bidirect.array)
  }
  
  
  ########################################################################################################################
  #### (7)  'bidirect.polar'
  #### Start-> INPUT feedback;  Action -> intensify || flip in sign with IDENTICAL SLOPE;  End -> MAXIMUM/MINIMUM CONSTRAINT
  if (direction == 'bidirect.polar'){
    
    # Create a 3-deminsion array  (i.e. a feedback matrix with a 3rd dimension: temporal change through time/age) 
    bidirect.dyn <- array(dim=c(nrow(feed), ncol(feed), scope))
    
    # Set the feedback for the very first time step as the original input
    bidirect.dyn[, , 1] <- feed
    
    # Set up movement for each time step
    # Get matrix for bidirectionality, either randomly generate it or take from input
    if(is.na(sum(bidirect.array))) {bidirect.array <- matrix(sample(c(-1, 1), replace=TRUE, size=nrow(feed) * ncol(feed)), nrow(feed), ncol(feed))}
    if(!is.na(sum(bidirect.array))) {bidirect.array <- bidirect.array}
    movement <- bidirect.array * ifelse(feed[, ] > 1, 1, -1) * inc
    
    # For each next time/age step (i.e. k-loop)
    # (a) Increase/decrease the strength of feedback based on the given bidirect arrary (-1's attenuate; 1's intensify)
    # (b) If there was originally no feedback, the value remains 1
    # (c) If the positive/negative feedback strength exceeds pos.feed.max/neg.feed.max, set it to pos.feed.max/neg.feed.max
    for(k in 2:scope){
      bidirect.dyn[, , k] <- bidirect.dyn[, , k-1] + movement
      bidirect.dyn[, , k] <- ifelse(bidirect.dyn[, , k-1] == 1, 1, bidirect.dyn[, , k])
      bidirect.dyn[, , k] <- ifelse(((bidirect.dyn[, , k] > pos.feed.max) | (bidirect.dyn[, , k] < neg.feed.max)), 
                                    ((bidirect.dyn[, , k] > 1)*pos.feed.max + (bidirect.dyn[, , k] < 1)*neg.feed.max), bidirect.dyn[, , k])
      
    }
    output <- list(dyn.feedback =  bidirect.dyn, input.array = bidirect.array)
  }

  
  ########################################################################################################################
  #### (8)  'slope.mag'
  #### Start-> INPUT feedback;  Action -> intensify with SPECIES-SPECIFIC SLOPE;  End -> MAXIMUM/MINIMUM CONSTRAINT
  if (direction == 'slope.mag'){
    
    # Create a 3-deminsion array  (i.e. a feedback matrix with a 3rd dimension: temporal change through time/age) 
    slope.dyn <- array(dim=c(nrow(feed), ncol(feed), scope))
    
    # Set the feedback for the very first time step as the original input
    slope.dyn[, , 1] <- feed
    
    # Set up movement for each time step
    # Get matrix for slope, either randomly generate it or take from input
    if(is.na(sum(slope.array))){slope.array <- matrix(runif(nrow(feed) * ncol(feed), slope.min, slope.max), nrow(feed), ncol(feed))}
    if(!is.na(sum(slope.array))){slope.array <- slope.array}
    movement <- ifelse(feed[, ] > 1, 1, -1) * slope.array
    
    # For each next time/age step (i.e. k-loop)
    # (a) Increase/decrease the strength of positive/negative feedback by given slope from the value of the previous time step
    # (b) If there was originally no feedback, the value remains 1
    # (c) If the positive/negative feedback strength exceeds pos.feed.max/neg.feed.max, set it to pos.feed.max/neg.feed.max
    for(k in 2:scope){
      slope.dyn[, , k] <- slope.dyn[, , k-1] + movement
      slope.dyn[, , k] <- ifelse(slope.dyn[, , k-1] == 1, 1, slope.dyn[, , k])
      slope.dyn[, , k] <- ifelse(((slope.dyn[, , k] > pos.feed.max) | (slope.dyn[, , k] < neg.feed.max)), 
                                 ((slope.dyn[, , k] > 1)*pos.feed.max + (slope.dyn[, , k] < 1)*neg.feed.max), slope.dyn[, , k])
    }
    output <- list(dyn.feedback =  slope.dyn, input.array = slope.array)
  }  
  
  
  ########################################################################################################################
  #### (9)  'slope.decay'
  #### Start-> INPUT feedback;  Action -> weaken with SPECIES-SPECIFIC SLOPE;  End -> ONE (i.e. NO FEEDBACK)
  if (direction == 'slope.decay'){
    
    # Create a 3-deminsion array  (i.e. a feedback matrix with a 3rd dimension: temporal change through time/age) 
    slope.dyn <- array(dim=c(nrow(feed), ncol(feed), scope))
    
    # Set the feedback for the very first time step as the original input
    slope.dyn[, , 1] <- feed
       
    # Set up movement for each time step
    # Get matrix for slope, either randomly generate it or take from input
    if(is.na(sum(slope.array))){slope.array <- matrix(runif(nrow(feed) * ncol(feed), slope.min, slope.max), nrow(feed), ncol(feed))}
    if(!is.na(sum(slope.array))){slope.array <- slope.array}
    movement <- ifelse(feed[, ] > 1, -1, 1) * slope.array
    
    # For each next time/age step (i.e. k-loop)
    # (a) Increase/decrease the strength of positive/negative feedback by given slope from the value of the previous time step
    # (b) If there was originally no feedback, the value remains 1
    # (c) If the positive/negative feedback strength exceeds pos.feed.max/neg.feed.max, set it to pos.feed.max/neg.feed.max
    for(k in 2:scope){
      slope.dyn[, , k] <- slope.dyn[, , k-1] + movement
      slope.dyn[, , k] <- ifelse(slope.dyn[, , k-1] == 1, 1, slope.dyn[, , k])
      slope.dyn[, , k] <- ifelse(((slope.dyn[, , k] - 1) * (slope.dyn[, , k-1] -1)) < 0, 1, slope.dyn[, , k])
    }
    output <- list(dyn.feedback =  slope.dyn, input.array = slope.array)
  }
  
  
  ########################################################################################################################
  #### (10) 'slope.flip'
  #### Start-> INPUT feedback;  Action -> flip in sign with SPECIES-SPECIFIC SLOPE;  End -> MAXIMUM/MINIMUM CONSTRAINT 
  if (direction == 'slope.flip'){
    
    # Create a 3-deminsion array  (i.e. a feedback matrix with a 3rd dimension: temporal change through time/age) 
    flip.dyn <- array(dim=c(nrow(feed), ncol(feed), scope))
    
    # Set the feedback for the very first time step as the original input
    flip.dyn[, , 1] <- feed
    
    # Get matrix for slope, either randomly generate it or take from input
    if(is.na(sum(slope.array))){slope.array <- matrix(runif(nrow(feed) * ncol(feed), slope.min, slope.max), nrow(feed), ncol(feed))}
    if(!is.na(sum(slope.array))){slope.array <- slope.array}
    movement <- ifelse(feed[, ] > 1, -1, 1) * slope.array
    
    # For each next time/age step (i.e. k-loop)
    # (a) Decrease/increase the strength of positive/negative feedback by given slope from the value of the previous time step
    # (b) If there was originally no feedback, the value remains 1
    # (c) If the positive/negative feedback strength exceeds pos.feed.max/neg.feed.max, set it to pos.feed.max/neg.feed.max
    for(k in 2:scope){
      flip.dyn[, , k] <- flip.dyn[, , k-1] + movement
      flip.dyn[, , k] <- ifelse(flip.dyn[, , k-1] == 1, 1, flip.dyn[, , k])
      flip.dyn[, , k] <- ifelse(((flip.dyn[, , k] > pos.feed.max) | (flip.dyn[, , k] < neg.feed.max)), 
                                ((flip.dyn[, , k] > 1)*pos.feed.max + (flip.dyn[, , k] < 1)*neg.feed.max), flip.dyn[, , k])
    }
    output <- list(dyn.feedback =  flip.dyn, input.array = slope.array)
  }
  
  
  ########################################################################################################################
  #### (11) 'slope.diverge'
  #### Start-> ONE (i.e. NO FEEDBACK);  Action -> intensify with SPECIES-SPECIFIC SLOPE;  End -> INPUT feedback
  # If "9", diverge with species-specific slope (feedback starts from 1 and then linearly increases/decreases with species-specific slope toward the randomly generated value)
  if (direction == 'slope.diverge'){
    
    # Create a 3-deminsion array  (i.e. a feedback matrix with a 3rd dimension: temporal change through time/age) 
    diverge.dyn <- array(dim=c(nrow(feed), ncol(feed), scope))
    
    # Set the feedback for the very first time step as 1
    diverge.dyn[, , 1] <- 1
    
    # Get matrix for slope, either randomly generate it or take from input
    if(is.na(sum(slope.array))){slope.array <- matrix(runif(nrow(feed) * ncol(feed), slope.min, slope.max), nrow(feed), ncol(feed))}
    if(!is.na(sum(slope.array))){slope.array <- slope.array}
    movement <- ifelse(feed[, ] > 1, 1, -1) * slope.array
    
    # For each next time/age step (i.e. k-loop)
    # (a) If there was originally no feedback, the value remains 1
    # (b) Increase/decrease the strength by given slope towards the targeted positive/negative feedback set by the input 'feed'
    # (c) If the positive/negative feedback strength exceeds that set by 'feed', stay at the assigned value since that is the maximum/minimum
    for(k in 2:scope){
      diverge.dyn[, , k] <- ifelse(diverge.dyn[, , k-1] != feed[, ], diverge.dyn[, , k-1] + movement, diverge.dyn[, , k-1])
      diverge.dyn[, , k] <- ifelse(((diverge.dyn[, , k] - feed[, ]) * (diverge.dyn[, , k-1] - feed[, ])) <= 0, feed[, ], diverge.dyn[, , k])
    }
    output <- list(dyn.feedback =  diverge.dyn, input.array = slope.array)
  } 
  
  
  ########################################################################################################################
  #### (12) 'slope.bidirect.extreme'v
  #### Start-> INPUT feedback;  Action -> intensify || weaken with SPECIES-SPECIFIC SLOPE;  End -> MAXIMUM/MINIMUM CONSTRAINT || ONE
  if (direction == 'slope.bidirect.extreme'){
    
    # Create a 3-deminsion array  (i.e. a feedback matrix with a 3rd dimension: temporal change through time/age) 
    bidirect.dyn <- array(dim=c(nrow(feed), ncol(feed), scope))
    
    # Set the feedback for the very first time step as the original input
    bidirect.dyn[, , 1] <- feed
    
    # Set up movement for each time step
    # Get matrix for bidirectionality and slope, either randomly generate it or take from input
    if(is.na(sum(bidirect.array))) {bidirect.array <- matrix(sample(c(-1, 1), replace=TRUE, size=nrow(feed) * ncol(feed)), nrow(feed), ncol(feed))}
    if(!is.na(sum(bidirect.array))) {bidirect.array <- bidirect.array}
    if(is.na(sum(slope.array))){slope.array <- matrix(runif(nrow(feed) * ncol(feed), slope.min, slope.max), nrow(feed), ncol(feed))}
    if(!is.na(sum(slope.array))){slope.array <- slope.array}
    movement <- bidirect.array * ifelse(feed[, ] > 1, 1, -1) * slope.array
    
    # For each next time/age step (i.e. k-loop)
    # (a) Increase/decrease the strength of feedback based on the given bidirect arrary (-1's attenuate; 1's intensify) by given slope 
    # (b) If there was originally no feedback, the value remains 1
    # (c) If the positive/negative feedback strength exceeds pos.feed.max/neg.feed.max || crosses one, set it to pos.feed.max/neg.feed.max || one
    for(k in 2:scope){
      bidirect.dyn[, , k] <- bidirect.dyn[, , k-1] + movement
      bidirect.dyn[, , k] <- ifelse(bidirect.dyn[, , k-1] == 1, 1, bidirect.dyn[, , k])
      bidirect.dyn[, , k] <- ifelse(((bidirect.dyn[, , k] - 1) * (bidirect.dyn[, , k-1] - 1)) <= 0, 1, bidirect.dyn[, , k])
      bidirect.dyn[, , k] <- ifelse(((bidirect.dyn[, , k] > pos.feed.max) | (bidirect.dyn[, , k] < neg.feed.max)), 
                                    ((bidirect.dyn[, , k] > 1)*pos.feed.max + (bidirect.dyn[, , k] < 1)*neg.feed.max), bidirect.dyn[, , k])
      
    }
    output <- list(dyn.feedback =  bidirect.dyn, input.array = list(slope.array, bidirect.array))
  }
  
  
  ########################################################################################################################
  #### (13) 'slope.bidirect.polar'
  #### Start-> INPUT feedback;  Action -> intensify || flip in sign with SPECIES-SPECIFIC SLOPE;  End -> MAXIMUM/MINIMUM CONSTRAINT
  if (direction == 'slope.bidirect.polar'){
    
    # Create a 3-deminsion array  (i.e. a feedback matrix with a 3rd dimension: temporal change through time/age) 
    bidirect.dyn <- array(dim=c(nrow(feed), ncol(feed), scope))
    
    # Set the feedback for the very first time step as the original input
    bidirect.dyn[, , 1] <- feed
    
    # Set up movement for each time step
    # Get matrix for bidirectionality and slope, either randomly generate it or take from input
    if(is.na(sum(bidirect.array))) {bidirect.array <- matrix(sample(c(-1, 1), replace=TRUE, size=nrow(feed) * ncol(feed)), nrow(feed), ncol(feed))}
    if(!is.na(sum(bidirect.array))) {bidirect.array <- bidirect.array}
    if(is.na(sum(slope.array))){slope.array <- matrix(runif(nrow(feed) * ncol(feed), slope.min, slope.max), nrow(feed), ncol(feed))}
    if(!is.na(sum(slope.array))){slope.array <- slope.array}
    movement <- bidirect.array * ifelse(feed[, ] > 1, 1, -1) * slope.array
    
    # For each next time/age step (i.e. k-loop)
    # (a) Increase/decrease the strength of feedback based on the given bidirect arrary (-1's attenuate; 1's intensify) by given slope 
    # (b) If there was originally no feedback, the value remains 1
    # (c) If the positive/negative feedback strength exceeds pos.feed.max/neg.feed.max, set it to pos.feed.max/neg.feed.max
    for(k in 2:scope){
      bidirect.dyn[, , k] <- bidirect.dyn[, , k-1] + movement
      bidirect.dyn[, , k] <- ifelse(bidirect.dyn[, , k-1] == 1, 1, bidirect.dyn[, , k])
      bidirect.dyn[, , k] <- ifelse(((bidirect.dyn[, , k] > pos.feed.max) | (bidirect.dyn[, , k] < neg.feed.max)), 
                                    ((bidirect.dyn[, , k] > 1)*pos.feed.max + (bidirect.dyn[, , k] < 1)*neg.feed.max), bidirect.dyn[, , k])
      
    }
    output <- list(dyn.feedback =  bidirect.dyn, input.array = list(slope.array, bidirect.array))
  }
  
  ########################################################################################################################
  #### (14) 'forever.mag'
  #### Start-> INPUT feedback;  Action -> intensify with IDENTICAL SLOPE;  End -> INFINITY
  if (direction == 'forever.mag'){
    
    # Create a 3-deminsion array  (i.e. a feedback matrix with a 3rd dimension: temporal change through time/age) 
    magnify.dyn <- array(dim=c(nrow(feed), ncol(feed), scope))
    
    # Set the feedback for the very first time step as the original input
    magnify.dyn[, , 1] <- feed
    
    # Set up movement for each time step
    movement <- ifelse(feed[, ] > 1, 1, -1) * inc 
    
    # For each next time/age step (i.e. k-loop)
    # (a) Increase/decrease the strength of positive/negative feedback by given increment from the value of the previous time step
    # (b) If there was originally no feedback, the value remains 1
    # (c) If the positive/negative feedback strength exceeds pos.feed.max/neg.feed.max, KEEP GOING    
    for(k in 2:scope){
      magnify.dyn[, , k] <- magnify.dyn[, , k-1] + movement
      magnify.dyn[, , k] <- ifelse(magnify.dyn[, , k-1] == 1, 1, magnify.dyn[, , k])
    }
    output <- list(dyn.feedback = magnify.dyn)
  }
  
  
  ########################################################################################################################
  #### (15) 'forever.flip'
  #### Start-> INPUT feedback;  Action -> flip in sign with IDENTICAL SLOPE;  End -> INFINITY
  if (direction == 'forever.flip'){
    
    # Create a 3-deminsion array  (i.e. a feedback matrix with a 3rd dimension: temporal change through time/age) 
    decay.dyn <- array(dim=c(nrow(feed), ncol(feed), scope))
    
    # Set the feedback for the very first time step as the original input
    decay.dyn[, , 1] <- feed
    
    # Set up movement for each time step
    movement <- ifelse(feed[, ] > 1, -1, 1) * inc 
    
    # For each next time/age step (i.e. k-loop)
    # (a) Decrease/increase the strength of positive/negative feedback by given increment from the value of the previous time step
    # (b) If there was originally no feedback, the value remains 1
    # (c) If the positive/negative feedback strength decreases/increases to below/above 1, KEEP GOING IN THE OTHER DIRECTION
    for(k in 2:scope){
      decay.dyn[, , k] <- decay.dyn[, , k-1] + movement
      decay.dyn[, , k] <- ifelse(decay.dyn[, , 1] == 1, 1, decay.dyn[, , k])
    }
    output <- list(dyn.feedback =  decay.dyn)
  }
  
  ########################################################################################################################
  #### (16) 'forever.bidirect.polar'
  #### Start-> INPUT feedback;  Action -> intensify || flip in sign with IDENTICAL SLOPE;  End -> INFINITY
  if (direction == 'forever.bidirect.polar'){
    
    # Create a 3-deminsion array  (i.e. a feedback matrix with a 3rd dimension: temporal change through time/age) 
    bidirect.dyn <- array(dim=c(nrow(feed), ncol(feed), scope))
    
    # Set the feedback for the very first time step as the original input
    bidirect.dyn[, , 1] <- feed
    
    # Set up movement for each time step
    # Get matrix for bidirectionality and slope, either randomly generate it or take from input
    if(is.na(sum(bidirect.array))) {bidirect.array <- matrix(sample(c(-1, 1), replace=TRUE, size=nrow(feed) * ncol(feed)), nrow(feed), ncol(feed))}
    if(!is.na(sum(bidirect.array))) {bidirect.array <- bidirect.array}
    movement <- bidirect.array * ifelse(feed[, ] > 1, 1, -1) * inc
    
    # For each next time/age step (i.e. k-loop)
    # (a) Increase/decrease the strength of feedback based on the given bidirect arrary (-1's attenuate; 1's intensify)
    # (b) If there was originally no feedback, the value remains 1
    # (c) If the positive/negative feedback strength exceeds pos.feed.max/neg.feed.max || crosses one, KEEP GOING || KEEP GOING IN THE OTHER DIRECTION
    for(k in 2:scope){
      bidirect.dyn[, , k] <- bidirect.dyn[, , k-1] + movement
      bidirect.dyn[, , k] <- ifelse(bidirect.dyn[, , k-1] == 1, 1, bidirect.dyn[, , k])
    }
    output <- list(dyn.feedback =  bidirect.dyn, input.array = bidirect.array)
  }  
  
  
  ########################################################################################################################
  #### (17) 'slope.forever.mag'
  #### Start-> INPUT feedback;  Action -> intensify with SPECIES-SPECIFIC SLOPE;  End -> INFINITY
  if (direction == 'slope.forever.mag'){
    
    # Create a 3-deminsion array  (i.e. a feedback matrix with a 3rd dimension: temporal change through time/age) 
    magnify.dyn <- array(dim=c(nrow(feed), ncol(feed), scope))
    
    # Set the feedback for the very first time step as the original input
    magnify.dyn[, , 1] <- feed
    
    # Set up movement for each time step
    if(is.na(sum(slope.array))){slope.array <- matrix(runif(nrow(feed) * ncol(feed), slope.min, slope.max), nrow(feed), ncol(feed))}
    if(!is.na(sum(slope.array))){slope.array <- slope.array}
    movement <- ifelse(feed[, ] > 1, 1, -1) * slope.array 
    
    # For each next time/age step (i.e. k-loop)
    # (a) Increase/decrease the strength of positive/negative feedback by given slope from the value of the previous time step
    # (b) If there was originally no feedback, the value remains 1
    # (c) If the positive/negative feedback strength exceeds pos.feed.max/neg.feed.max, KEEP GOING    
    for(k in 2:scope){
      magnify.dyn[, , k] <- magnify.dyn[, , k-1] + movement
      magnify.dyn[, , k] <- ifelse(magnify.dyn[, , k-1] == 1, 1, magnify.dyn[, , k])
    }
    output <- list(dyn.feedback = magnify.dyn, input.array = slope.array)
  }
  
  
  ########################################################################################################################
  #### (18) 'slope.forever.flip'
  #### Start-> INPUT feedback;  Action -> flip in sign with SPECIES-SPECIFIC SLOPE;  End -> INFINITY
  if (direction == 'slope.forever.flip'){
    
    # Create a 3-deminsion array  (i.e. a feedback matrix with a 3rd dimension: temporal change through time/age) 
    decay.dyn <- array(dim=c(nrow(feed), ncol(feed), scope))
    
    # Set the feedback for the very first time step as the original input
    decay.dyn[, , 1] <- feed
    
    # Set up movement for each time step
    if(is.na(sum(slope.array))){slope.array <- matrix(runif(nrow(feed) * ncol(feed), slope.min, slope.max), nrow(feed), ncol(feed))}
    if(!is.na(sum(slope.array))){slope.array <- slope.array}
    movement <- ifelse(feed[, ] > 1, -1, 1) * slope.array
    
    # For each next time/age step (i.e. k-loop)
    # (a) Decrease/increase the strength of positive/negative feedback by given slope from the value of the previous time step
    # (b) If there was originally no feedback, the value remains 1
    # (c) If the positive/negative feedback strength decreases/increases to below/above 1, KEEP GOING IN THE OTHER DIRECTION
    for(k in 2:scope){
      decay.dyn[, , k] <- decay.dyn[, , k-1] + movement
      decay.dyn[, , k] <- ifelse(decay.dyn[, , 1] == 1, 1, decay.dyn[, , k])
    }
    output <- list(dyn.feedback =  decay.dyn, input.array = slope.array)
  }
  
  ########################################################################################################################
  #### (19) 'slope.forever.bidirect.polar'
  #### Start-> INPUT feedback;  Action -> intensify || flip in sign with SPECIES-SPECIFIC SLOPE;  End -> INFINITY
  if (direction == 'slope.forever.bidirect.polar'){
    
    # Create a 3-deminsion array  (i.e. a feedback matrix with a 3rd dimension: temporal change through time/age) 
    bidirect.dyn <- array(dim=c(nrow(feed), ncol(feed), scope))
    
    # Set the feedback for the very first time step as the original input
    bidirect.dyn[, , 1] <- feed
    
    # Set up movement for each time step
    # Get matrix for bidirectionality and slope, either randomly generate it or take from input
    if(is.na(sum(bidirect.array))) {bidirect.array <- matrix(sample(c(-1, 1), replace=TRUE, size=nrow(feed) * ncol(feed)), nrow(feed), ncol(feed))}
    if(!is.na(sum(bidirect.array))) {bidirect.array <- bidirect.array}
    if(is.na(sum(slope.array))){slope.array <- matrix(runif(nrow(feed) * ncol(feed), slope.min, slope.max), nrow(feed), ncol(feed))}
    if(!is.na(sum(slope.array))){slope.array <- slope.array}
    movement <- bidirect.array * ifelse(feed[, ] > 1, 1, -1) * slope.array
    
    # For each next time/age step (i.e. k-loop)
    # (a) Increase/decrease the strength of feedback based on the given bidirect arrary (-1's attenuate; 1's intensify) by given slope 
    # (b) If there was originally no feedback, the value remains 1
    # (c) If the positive/negative feedback strength exceeds pos.feed.max/neg.feed.max || crosses one, KEEP GOING || KEEP GOING IN THE OTHER DIRECTION
    for(k in 2:scope){
      bidirect.dyn[, , k] <- bidirect.dyn[, , k-1] + movement
      bidirect.dyn[, , k] <- ifelse(bidirect.dyn[, , k-1] == 1, 1, bidirect.dyn[, , k])
    }
    output <- list(dyn.feedback =  bidirect.dyn, input.array = list(bidirect.array, slope.array))
  }
  
  
  # Output of the function is a list with one element: "dyn.feedback"
  return(output)
  
} # End of function body




########################################################################################################################
#### This function takes in the 3-dimension demographically dynamic feedback array and plots it through time
########################################################################################################################


#### This function takes in: 
####      (1) dynamic.feedback: the 3-dimension demographically dynamic feedback array generated by "generateDemogFeedbacks" (i.e. the $dyn.feedback part of the output)
plotDynFeedbacks <- function(dynamic.feedback){
  
  # Reiterate input variables (i.e. place-holders)
  x <- dynamic.feedback
  
  # Reshape the dyn.feedback into one single table, each column is one time/age step, each row is one S_{ij} (original matrix was read into a single column with byrow=F)
  reduced.dyn <- array(c(x), dim=c(nrow(x)*ncol(x), dim(x)[3]))
  reduced.dyn <- reshape::melt(reduced.dyn)
  names(reduced.dyn) <- c("Pair", "Time", "Value")
  reduced.dyn <- reduced.dyn[!is.na(reduced.dyn$Value), ]
  
  # Plot and point temporal patterns of each S_{ij} as a separate line
  p <- ggplot(reduced.dyn, aes(x=Time, y=Value)) + 
       geom_point(color="black", alpha=0.75) + 
       geom_line(aes(group=Pair), color="black", alpha=0.75) + 
       geom_hline(yintercept=1, color="grey", linetype=3) + 
       scale_x_continuous("Plant age") +
       scale_y_continuous("Feedback strength", limits=c(0.5, 1.5)) + 
       theme_classic()
  return(p)
  
} # End of function body


# #### One run example
# feed = defineFeed(4, size=5)
# feed.demo = generateDemogFeedbacks(feed$feed, 20, increment=0.01, direction='mag')
# plotDynFeedbacks(generateDemogFeedbacks(feed$feed, 20, increment=0.01, direction='mag')$dyn.feedback)

